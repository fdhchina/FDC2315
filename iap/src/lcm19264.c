#include "hal.h"
#include "lcm19264.h"

#if (_HAVE_FONTLIB_ ==FONT_CODE)	// 字库放在程序中
#include "ascii12.h"
#include "sthzk12.h"
#elif (_HAVE_FONTLIB_==FONT_FLASH)	// 字库放在Flash中
const u8* const ASCII12= (const u8*)sacFont_Ascii12;		// 英文字库地址
const u8* const HZK12	= (const u8*)sacFont_Hzk12;		// 中文字库地址
#else	// 字库放在SPI存储器中
#include <string.h>
#include "25f.h"
static u8 ZK_BUF[32];		// 定义字库读取缓冲，最大32个字节
#endif

#define LCM_DELAY  4

// ========================================================================================
// 硬件端口
// 数据方向控制
#define LCM_E_Port		GPIOB
#define LCM_E_Pin		GPIO_Pin_5

#define LCM_RW_Port		GPIOB
#define LCM_RW_Pin		GPIO_Pin_6

#define LCM_RS_Port		GPIOB
#define LCM_RS_Pin		GPIO_Pin_7

#define LCM_CSB_Port	GPIOB
#define LCM_CSB_Pin		GPIO_Pin_8

#define LCM_CSA_Port	GPIOB
#define LCM_CSA_Pin		GPIO_Pin_9

#define LCM_BG_Port		GPIOE
#define LCM_BG_Pin		GPIO_Pin_0
//#define LCM_DATA_OUT()	{GPIOD->CRH= 0x33333333; LCM_DIR_Port->BRR= LCM_DIR_Pin;}	// 4245为3V3->5V  // 推挽输出50MHZ速度	
//#define LCM_DATA_IN()	{GPIOD->CRH= 0x44444444; LCM_DIR_Port->BSRR= LCM_DIR_Pin;}	// 4245为5V->3V3  // 浮空输入
	
//#define LCM_GET_DATA()		((GPIOD->IDR>>8)&0xff)
//#define LCM_SET_DATA(dat)	GPIOD->BSRR=((dat<<8)|((~dat)<<24))	// 这个可用ODR寄存器
u8 LCM_GET_DATA() {
	u16 datt;
	datt = GPIO_ReadInputData(GPIOD);
	return datt&0xff;
}

void LCM_SET_DATA(u8 dat) {
	u16 datt;
	datt = GPIO_ReadInputData(GPIOD);
	datt = ((datt&~(0xFF)) | ((dat&0xFF)));
	GPIO_Write(GPIOD, datt);
}void lcm_dat_in()
{
	GPIOD->CRL= 0x33333333;
}
void lcm_dat_out()
{
	GPIOD->CRL= 0x44444444;
}
#define LCM_DATA_OUT()	lcm_dat_in()	// 4245为3V3->5V  // 推挽输出50MHZ速度	
#define LCM_DATA_IN()	lcm_dat_out()	// 4245为5V->3V3  // 浮空输入

// ========================================================================================

#define SET_LCM_RS() \
        LCM_RS_Port->BSRR = LCM_RS_Pin
#define CLR_LCM_RS() \
        LCM_RS_Port->BRR = LCM_RS_Pin

#define SET_LCM_RW() \
        LCM_RW_Port->BSRR = LCM_RW_Pin
#define CLR_LCM_RW() \
        LCM_RW_Port->BRR = LCM_RW_Pin
                
#define SET_LCM_E() \
        LCM_E_Port->BSRR=LCM_E_Pin
#define CLR_LCM_E() \
        LCM_E_Port->BRR=LCM_E_Pin

#define SET_LCM_CSA() \
        LCM_CSA_Port->BSRR=LCM_CSA_Pin
#define CLR_LCM_CSA() \
        LCM_CSA_Port->BRR=LCM_CSA_Pin

#define SET_LCM_CSB() \
        LCM_CSB_Port->BSRR = LCM_CSB_Pin
#define CLR_LCM_CSB() \
        LCM_CSB_Port->BRR = LCM_CSB_Pin

// 背光低电平驱动
#define SETGroudLight() \
        LCM_BG_Port->BSRR = LCM_BG_Pin
#define CLRGroudLight() \
        LCM_BG_Port->BRR = LCM_BG_Pin
		
#define LCM_WRITE(data) \
        LCM_SET_DATA(data)

#define LCM_READ LCM_GET_DATA

typedef unsigned char *	PUINT8;
/***********常用操作命令和参数定义***************/
#define	 DispOn		0x3f	/*显示on		*/
#define	 DispOff		0x3e	/*显示off		*/
#define	 DispFirst	0xc0	/*显示起始行定义	*/
#define	 SetX		0x40	/*X定位设定指令（页）	*/
#define	 SetY		0xb8	/*Y定位设定指令（列）	*/
#define	 LcdBusy	0x80	/*LCM忙判断位		*/

/**************显示分区边界位置*****************/
#define	 MODL		0x00	/*左区			*/
#define	 MODM		0x40	/*左区和中区分界	*/
#define	 MODR		0x80	/*中区和右区分界	*/
#define	 LCMLIMIT	0xC0	/*显示区的右边界	*/

void lcmDelay (int nDelay)
{
	while(nDelay--);
}


void lcm_BackLightCtrl(u8 opened)
{
	if(opened)
		SETGroudLight();
	else
		CLRGroudLight();
}

void wtcom()
{
	u8 i=255;
  	// lcmDelay(LCM_DELAY);
	CLR_LCM_RS();		
	SET_LCM_RW();		
	SET_LCM_E();
	
	LCM_DATA_IN();	
  	lcmDelay(LCM_DELAY*40);
   	while((LCM_READ() & LcdBusy)&&(i--));
   	CLR_LCM_E();
	LCM_DATA_OUT();	 
  	lcmDelay(LCM_DELAY*40);
}

/********************************************************/
/* 分区操作允许等待,返回时保留分区选择状态		*/
/********************************************************/
void LcdSelectL()
{
	CLR_LCM_CSA();
	CLR_LCM_CSB();
}

void LcdSelectM()
{
	CLR_LCM_CSA();
	SET_LCM_CSB();
}

void LcdSelectR()
{
	SET_LCM_CSA();
	CLR_LCM_CSB();
}

void Wrcmd(u8 X)
{
	wtcom();
	CLR_LCM_RS();			/*命令操作	*/
	CLR_LCM_RW();			/*写输出  	*/
  	lcmDelay(LCM_DELAY);
	SET_LCM_E();
	LCM_WRITE(X);			/*数据输出到数据口 */
	lcmDelay (LCM_DELAY);
	CLR_LCM_E();	/*读入到LCM*/
	lcmDelay (LCM_DELAY);
}

void Wrdat (u8 X)
{
	wtcom();
	SET_LCM_RS();	/*数据输出*/
	CLR_LCM_RW();	/*写输出  */
  	lcmDelay(LCM_DELAY);
	SET_LCM_E();	/*读入到LCM*/
	LCM_WRITE(X);	/*数据输出到数据口 */
  	lcmDelay (LCM_DELAY);
	CLR_LCM_E();
	lcmDelay (LCM_DELAY);
}

void WrcmdL(u8 X)
{
	LcdSelectL();		/*确定分区，返回时保留分区状态不变*/
	Wrcmd(X);
}

/********************************/
/* 命令输出到中区控制口		*/
/********************************/

void WrcmdM(u8 X)  
{
	LcdSelectM();		/*确定分区，返回时保留分区状态不变*/
	Wrcmd(X);
}

/********************************/
/* 命令输出到右区控制口		*/
/********************************/

void WrcmdR(u8 X)
{
	LcdSelectR();	/*确定分区，返回时保留分区状态不变	*/
	Wrcmd(X);
}

/********************************************************/
/*根据设定的坐标数据，定位LCM上的下一个操作单元位置	*/
/********************************************************/
void Locatexy(u8 Ax,u8 Ay)
{
	u8  x,y;
	x=Ax&0xC0;
	if (x==0)		
		LcdSelectL();	//左区	
	else
		if(x==0x40)
			LcdSelectM();
		else
			LcdSelectR();

	x = (Ax&0x3F)|SetX;		
	y = (Ay&0x07)|SetY;		

	Wrcmd(y);
	Wrcmd(x);
}

void lcm_DisplayOpen(u8 opened)
{
	u8 byt= opened?DispOn:DispOff;
	WrcmdL(byt);
	WrcmdM(byt);
	WrcmdR(byt);
}

void lcm_Configuration()
{
	GPIO_InitTypeDef GPIO_InitStructure;

	// D
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOE, ENABLE);

	//PD1-BG, PD2-CSA, PD3-CSB, PD4-RS, PD5-RW, PD6-E, PD7-DIR
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	//推挽输出
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	//50M时钟速度
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
	//D8-D15口因为使用了IO,所以不在这里配置
}

void lcm_Init ()
{
	u8	cu8;
	
	LCM_DATA_OUT();	
	CLRGroudLight();
	lcm_DisplayOpen(FALSE);

	cu8 = DispFirst;	//+62;	/*定义显示起始行为零	*/
	WrcmdL(cu8);
	WrcmdM(cu8);
	WrcmdR(cu8);
	
	lcm_DisplayOpen(DispOn);
	SETGroudLight();
	lcm_Clr();
}

/****************************************/
/*	一个字串的输出			*/
/****************************************/
void lcm_Putstr(u8 AX, u8 AY, u8 *puts, u8 len, u8 instead)
{
	u8 j;
	j=0;
	if(len==0) len= 255;
	while((puts[j]!=0)&&(j<len))
	{
		if(((u8)puts[j]>0xA0)&&(j+1<len)&&((u8)puts[j+1]>0xA0))
		{
			lcm_Putcdot(AX,AY,puts[j]-0xA1,puts[j+1]-0xA1,instead); /*只保留低7位*/
			AX+=12;
			if(AX>191){
				AX=0;
				AY+=16;
			}
			j+=2;
		}else
		{
			if(puts[j]<0x7F)
				lcm_Putedot(AX,AY,puts[j]-0x20,instead);		/*ascii码表从0x20开始*/
			else
				lcm_Putedot(AX,AY,' '-0x20,instead);		/*ascii码表从0x20开始*/
			AX+=6;
			if(AX>191){
				AX=0;
				AY+=16;
			}
			j++;
		}
	}
}

/****************************************/
/*   半角字符点阵码数据输出		*/
/****************************************/
void lcm_Putedot(u8 AX, u8 AY, u8 Order, u8 instead)
{
	u8 i,bakerx,bakery,cu8, *buf;	/*共定义4个局部变量			*/
	int x;			/*偏移量，字符量少的可以定义为u8	*/
	bakerx = AX;		/*暂存x,y坐标，已备下半个字符使用	*/
	bakery = AY;
	x=Order * 0xC;		/*半角字符，每个字符12个字节	*/

#if _HAVE_FONTLIB_
	buf= (u8 *)ASCII12+x;
#else
	buf=ZK_BUF;
	sst25_Read(sacFont_Ascii12+x, buf, 12);
#endif
	/*上半个字符输出，6列	*/
	for(i=0;i<6;i++)
	{
		cu8 = *buf++;				/*取点阵码，rom数组	*/
		if(instead==1) 
		 cu8=~cu8;
		Locatexy(AX,AY);
		Wrdat(cu8);				/*写输出一字节		*/
		x++;
		AX++;
		if (AX==LCMLIMIT){AX=0;AY++;AY++;};	/*下一列，如果列越界换行*/
			if (AY>7) AY=0;		/*如果行越界，返回首行	*/
	}					/*上半个字符输出结束	*/

	AX = bakerx;					/*列对齐		*/
	AY = bakery+1;					/*指向下半个字符行	*/
		/*下半个字符输出，6列	*/
	for(i=0;i<6;i++)
	{
		cu8 = *buf++;				/*取点阵码		*/
		if(instead==1) 
		{
			 cu8=~cu8;
			 cu8&=0x0f;
		 }
		Locatexy(AX,AY);
		Wrdat(cu8);				/*写输出一字节		*/
		x++;
		AX++;
		if (AX==LCMLIMIT){AX=0;AY=AY+2;};	/*下一列，如果列越界换行*/
			if (AY>7) AY=0;		/*如果行越界，返回首行	*/
	}					/*下半个字符输出结束	*/
	//AY=bakery;
}						/*整个字符输出结束	*/


/****************************************/
/*  全角字符点阵码数据输出		*/
/****************************************/
void lcm_Putcdot(u8 AX,u8 AY,u8 Order,u8 Order1,u8 instead)
{
	u8 i,bakerx,bakery,cu8, *buf;		/*共定义3个局部变量		*/
	int x;				/*偏移量，字符量少的可以定义为u8	*/
	bakerx = AX;			/*暂存x,y坐标，已备下半个字符使用	*/
	bakery = AY;
	x= ((unsigned long)Order*94 + Order1)*24;		/*全角字符，每个字符24字节	*/
#if _HAVE_FONTLIB_
	buf= (u8 *)HZK12+x;
#else
	buf=ZK_BUF;
	sst25_Read(sacFont_Hzk12+x, buf, 24);
#endif

	/*上半个字符输出，16列	*/
	for(i=0;i<12;i++)
	{
		cu8=*buf++;
		if(instead==1) 
			cu8=~cu8;
		Locatexy(AX,AY);
		Wrdat(cu8);				/*写输出一字节		*/
		x++;
		AX++;
		if (AX==LCMLIMIT)
		{ 
			AX=0;
			AY++;
			AY++;
		}	/*下一列，如果列越界换行*/
		if (AY>7) 
			AY=0;		/*如果行越界，返回首行	*/
	}					/*上半个字符输出结束	*/
		
	/*下半个字符输出，16列	*/
	AX = bakerx;
	AY = bakery+1;
	for(i=0;i<12;i++)				/*下半部分*/
	{
		cu8= *buf++;
		if(instead==1) 
		{
			 cu8=~cu8;
			 cu8&=0x0f;
		 }
		Locatexy(AX,AY);
		Wrdat(cu8);
		x++;
		AX++;
		if (AX==LCMLIMIT)
		{
			AX=0;
			AY++;
			AY++;
		}	/*下一列，如果列越界换行*/
		if (AY>7) 
			AY=0;		/*如果行越界，返回首行	*/
	}					/*下半个字符输出结束	*/
	//AY = bakery;
}						/*整个字符输出结束	*/

/****************************************/
/*	清屏，全屏幕清零		*/
/****************************************/
void lcm_Clr()
{
	u8 col,row;
	for(row=0;row<8;row++)
	{
		for(col=0;col<LCMLIMIT;col++) 
		{
			if((col&0x3F)==0)
	   			Locatexy(col, row);
   			Wrdat(0);
   		}
	}
}


const unsigned char nBitmapDot[];

void lcm_DisplayNoFont()
{
	u8 i,j, * buf=(u8 *)nBitmapDot;

	for(j=0;j<2;j++)
	{
		for(i=0;i<0xC0;i++)
		{
			Locatexy(i, j);
			Wrdat(0);
		}
	}
	for(j=2;j<6;j++)
	{
		for(i=0;i<0xC0;i++)
		{
			Locatexy(i, j);
			Wrdat(*buf++);
		}
	}
	for(j=6;j<8;j++)
	{
		for(i=0;i<0xC0;i++)
		{
			Locatexy(i, j);
			Wrdat(0);
		}
	}
}
/////////////////////////////////////////////////////////////////////////
// Bitmap点阵数据表                                                    //
// 图片: D:\..imo\test2.bmp,纵向取模下高位,数据排列:从左到右从上到下   //
// 图片尺寸: 192 * 32                                                  //
/////////////////////////////////////////////////////////////////////////
const unsigned char nBitmapDot[] =                  // 数据表
{
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x22,0x64,0x0C,0x80,0x04,0x74,0x84,
      0x04,0x04,0x04,0xC4,0x3E,0x04,0x00,0x00,0x00,0x10,0x0C,0x24,0x24,0x24,0x25,0x26,
      0xA4,0x64,0x24,0x04,0x14,0x0C,0x00,0x00,0x00,0x00,0xFC,0x24,0x24,0xA4,0x64,0x3D,
      0xA6,0x24,0x24,0x24,0x36,0x24,0x00,0x00,0x80,0x88,0x88,0x88,0x88,0x88,0x88,0xFF,
      0x88,0x88,0x88,0x88,0x8C,0xC8,0x80,0x00,0x90,0x8C,0x84,0x84,0x84,0x84,0xF5,0x86,
      0x84,0x84,0x84,0x84,0x84,0xD4,0x8C,0x00,0x00,0x42,0x24,0x10,0xFF,0x00,0x44,0xA4,
      0x24,0x3F,0x24,0x34,0x26,0x84,0x00,0x00,0x08,0x08,0xC8,0x48,0x48,0x48,0xE8,0x48,
      0x08,0xFF,0x08,0x09,0xCA,0x08,0x08,0x00,0x00,0x02,0xF2,0x42,0x42,0x42,0x42,0x42,
      0x42,0x42,0x42,0xFF,0x02,0x00,0x00,0x00,0x00,0x00,0x22,0x22,0x22,0x22,0x22,0xFE,
      0x21,0x21,0x21,0x31,0x20,0x00,0x00,0x00,0x00,0x40,0x20,0x1E,0x10,0x10,0x10,0xFF,
      0x10,0x10,0x10,0x18,0x10,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x7E,0x01,0x80,0x40,0x20,0x11,
      0x0A,0x04,0x0B,0x10,0x60,0xC0,0x40,0x00,0x02,0x02,0x02,0x02,0x02,0x42,0x82,0x7F,
      0x02,0x02,0x02,0x02,0x02,0x03,0x02,0x00,0x80,0x60,0x1F,0x10,0x13,0x12,0x12,0x12,
      0xFF,0x12,0x12,0x13,0x12,0x18,0x10,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0xFF,
      0x01,0x02,0x04,0x08,0x10,0x30,0x10,0x00,0x00,0x00,0x80,0x84,0x46,0x49,0x28,0x10,
      0x10,0x28,0x47,0xC0,0x00,0x00,0x00,0x00,0x01,0x21,0x21,0x11,0x09,0xFD,0x43,0x21,
      0x0D,0x11,0x29,0x25,0x43,0xC1,0x41,0x00,0x00,0x20,0x2F,0x24,0x24,0x14,0x97,0x90,
      0x40,0x27,0x18,0x26,0x41,0x80,0x70,0x00,0x00,0x00,0x3F,0x40,0x40,0x40,0x40,0x40,
      0x40,0x40,0x40,0x40,0x40,0x78,0x00,0x00,0x02,0x02,0x42,0x62,0x52,0x4A,0x46,0x43,
      0x42,0x42,0x52,0x62,0xC2,0x03,0x02,0x00,0x01,0x81,0x81,0x41,0x21,0x11,0x0D,0x03,
      0x0D,0x11,0x21,0x21,0x41,0xC1,0x41,0x00,0x00,0x00,0x00,0x46,0x2F,0x1F,0x06,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x20,0x22,0xEC,0x00,0x20,0x22,0xAA,0xAA,0xAA,0xBF,0xAA,0xAA,0xEB,0xA2,0x20,0x00,
      0x40,0x42,0x44,0xCC,0x00,0x00,0xFC,0x04,0xA4,0x24,0x24,0xA2,0x63,0x02,0x00,0x00,
      0x00,0xFC,0x04,0x04,0x04,0xE4,0x24,0x24,0x24,0xF4,0x24,0x04,0x04,0xFE,0x04,0x00,
      0x00,0x00,0x80,0x40,0x30,0x0C,0x00,0xC0,0x06,0x18,0x20,0x40,0x80,0x80,0x80,0x00,
      0x10,0x10,0x92,0x92,0x92,0x92,0x92,0x92,0xD2,0x9A,0x12,0x02,0xFF,0x02,0x00,0x00,
      0x20,0x30,0xAC,0x63,0x30,0x40,0x20,0xF8,0x4F,0x48,0x4A,0xFC,0x48,0x4C,0x08,0x00,
      0x40,0x20,0xF8,0x07,0xF0,0xA0,0x90,0x4F,0x54,0x24,0xD4,0x4C,0x84,0x80,0x80,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0xFE,0xFE,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x7F,0x20,0x10,0x00,0xFF,0x0A,0x0A,0x0A,0x4A,0x8A,0x7F,0x00,0x00,0x00,
      0x00,0x40,0x20,0x1F,0x20,0x58,0x87,0x90,0x88,0x85,0x82,0x85,0x88,0xD8,0x40,0x00,
      0x00,0x7F,0x20,0x20,0x20,0x2F,0x24,0x24,0x24,0x2F,0x20,0x20,0x20,0x7F,0x00,0x00,
      0x01,0x01,0x00,0x30,0x28,0x24,0x23,0x20,0x20,0x28,0x30,0x60,0x00,0x01,0x00,0x00,
      0x00,0x00,0x3F,0x10,0x10,0x10,0x10,0x10,0x3F,0x00,0x40,0x80,0x7F,0x00,0x00,0x00,
      0x22,0x63,0x22,0x12,0x12,0x12,0x00,0xFF,0x22,0x22,0x22,0x3F,0x22,0x32,0x20,0x00,
      0x00,0x00,0xFF,0x00,0x0F,0x80,0x92,0x52,0x49,0x25,0x24,0x12,0x08,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x3B,0x3B,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

