/* *****************************************************************************
2012-10-11
 	16G SD卡读没问题，写有问题
****************************************************************************** */
#include "hal.h"
#include "diskio.h"
#include "ff.h"
#include "msd.h"

static volatile DSTATUS msd_Stat = STA_NOINIT;	/* Disk status */

/******************************************************************************* 
*  本文件为SPI操作SD卡的底层驱动文件
*  包括SPI模块及相关IO的初始化，SPI读写SD卡（写指令，读数据等）
*******************************************************************************/   
#define SD_TYPE_MMC     0
#define SD_TYPE_V1      1
#define SD_TYPE_V2      2
#define SD_TYPE_V2HC    4

/* SPI总线速度设置*/
#define SPI_SPEED_LOW   0
#define SPI_SPEED_HIGH  1

/* SD传输数据结束后是否释放总线宏定义 */
#define NO_RELEASE      0
#define RELEASE         1
							  
#if 1
/* SD卡指令表 */
#define CMD0    0       //卡复位
#define CMD8	   8
#define CMD9    9       //命令9 ，读CSD数据
#define CMD10   10      //命令10，读CID数据
#define CMD12   12      //命令12，停止数据传输
#define CMD16   16      //命令16，设置SectorSize 应返回0x00
#define CMD17   17      //命令17，读sector
#define CMD18   18      //命令18，读Multi sector
#define ACMD23  23      //命令23，设置多sector写入前预先擦除N个block
#define CMD24   24      //命令24，写sector
#define CMD25   25      //命令25，写Multi sector
#define ACMD41  41      //命令41，应返回0x00
#define CMD55   55      //命令55，应返回0x01
#define CMD58   58      //命令58，读OCR信息
#define CMD59   59      //命令59，使能/禁止CRC，应返回0x00
#endif

#define SD_CS_ENABLE()  GPIO_ResetBits(GPIOA, GPIO_Pin_4)  //选中SD卡
#define SD_CS_DISABLE() GPIO_SetBits(GPIOA, GPIO_Pin_4)	  //取消选中				    	 

/* Private function prototypes -----------------------------------------------*/
/*
void SPI_Configuration(void);
void SPI_SetSpeed(u8 SpeedSet);

u8 SPI_ReadWriteByte(u8 TxData);                //SPI总线读写一个字节
u8 SD_WaitReady(void);                          //等待SD卡就绪
u8 SD_SendCommand(u8 cmd, u32 arg, u8 crc);     //SD卡发送一个命令
u8 SD_SendCommand_NoDeassert(u8 cmd, u32 arg, u8 crc);
*/
u8 SD_Init(void);                               //SD卡初始化
/*                                                //
u8 SD_ReceiveData(u8 *data, u16 len, u8 release);//SD卡读数据
u8 SD_GetCID(u8 *cid_data);                     //读SD卡CID
u8 SD_GetCSD(u8 *csd_data);                     //读SD卡CSD
*/
u32 SD_GetCapacity(void);                       //取SD卡容量

u8 SD_ReadSingleBlock(u32 sector, u8 *buffer);  //读一个sector
u8 SD_WriteSingleBlock(u32 sector, const u8 *buffer); //写一个sector
u8 SD_ReadMultiBlock(u32 sector, u8 *buffer, u8 count); //读多个sector
u8 SD_WriteMultiBlock(u32 sector, const u8 *data, u8 count);  //写多个sector
u8 SD_Read_Bytes(unsigned long address,unsigned char *buf,unsigned int offset,unsigned int bytes);//读取一byte

volatile BOOL SD_changed=TRUE;
volatile BOOL sd_insert_flag= FALSE;
volatile BOOL sd_valid_flag= FALSE;

u8  SD_Type=0;//SD卡的类型	 
////////////////////////////////////////////////////////////////////////////////
// 以下是SPI模块的初始化代码，配置成主机模式，访问SD卡
////////////////////////////////////////////////////////////////////////////////
//SD卡插入检测脚  SD_CD     PC4	SD卡插入检测
#if (GC_ZR&GC_ZR_GPIO)
#define SD_NCD_PORT	GPIOC
#define SD_NCD_Pin		GPIO_Pin_4
#define SD_SPI_NAME		1
#define sd_spi		SPI1
#define SD_DETECT	(!GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_4))
#else
#define SD_NCD_PORT	GPIOA
#define SD_NCD_Pin		GPIO_Pin_3
#define SD_SPI_NAME		1
#define sd_spi		SPI1
#define SD_DETECT	(!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_3))
#endif

BOOL	sd_IsInserted()
{
	return (BOOL)SD_DETECT;
}

void sd_Config()
{
	SPI_InitTypeDef  SPI_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
#if 1
	NVIC_InitTypeDef NVIC_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;
#endif	

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA  | RCC_APB2Periph_AFIO ,  ENABLE);
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;// | GPIO_Pin_3| GPIO_Pin_5| GPIO_Pin_6| GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	/*
	GPIO_SetBits(GPIOA, GPIO_Pin_3);
	GPIO_SetBits(GPIOA, GPIO_Pin_4);
	GPIO_SetBits(GPIOA, GPIO_Pin_5);
	GPIO_SetBits(GPIOA, GPIO_Pin_6);
	GPIO_SetBits(GPIOA, GPIO_Pin_7);

	GPIO_ResetBits(GPIOA, GPIO_Pin_3);
	GPIO_ResetBits(GPIOA, GPIO_Pin_4);
	GPIO_ResetBits(GPIOA, GPIO_Pin_5);
	GPIO_ResetBits(GPIOA, GPIO_Pin_6);
	GPIO_ResetBits(GPIOA, GPIO_Pin_7);
	*/
#if (GC_ZR&GC_ZR_GPIO)
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
#else
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
#endif
#if (SD_SPI_NAME==1)

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA  |
            RCC_APB2Periph_AFIO |
            RCC_APB2Periph_SPI1,
            ENABLE);

	/*A5=CLK,A6=MISO,A7=MOSI*/
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5  | GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	

#elif (SD_SPI_NAME==2)

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	// SCK, MISO and MOSI  B13=CLK,B14=MISO,B15=MOSI
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);


#elif (SD_SPI_NAME==3)

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	// SCK, MISO and MOSI  B3=CLK,B4=MISO,B5=MOSI
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

#endif 
	// SPI configuration  注意25系列的沿操作
	SPI_Cmd(sd_spi, DISABLE); 												//必须先禁能,才能改变MODE
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;		//两线全双工
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;							//主
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;						//8位
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;								//CPOL=1 时钟悬空高
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;							//CPHA=1 数据捕获第二个
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;								//软件NSS
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;	//256分频
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;						//高位在前
	SPI_InitStructure.SPI_CRCPolynomial = 7;								//CRC7

	SD_CS_DISABLE();
	SPI_Init(sd_spi, &SPI_InitStructure);
	// SPI_SSOutputCmd(sd_spi, ENABLE); //使能NSS脚可用
	SPI_Cmd(sd_spi, ENABLE); 
#if 1	// SD卡插入及拨出用中断检测
	/* 连接IO口到中断线 */
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource3);

	/*配置为下降沿触发*/
	EXTI_InitStructure.EXTI_Line = EXTI_Line3;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);
	
	// 键盘使用EXTI8-EXTI11中断
	NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	// sd_insert_flag= sd_IsInserted();
#endif
}

/*******************************************************************************
* Function Name  : sd_spi_SetSpeed
* Description    : SPI设置速度为高速
* Input          : u8 SpeedSet 
*                  如果速度设置输入0，则低速模式，非0则高速模式
*                  SPI_SPEED_HIGH   1
*                  SPI_SPEED_LOW    0
* Output         : None
* Return         : None
*******************************************************************************/
void sd_spi_SetSpeed(u8 SpeedSet)
{
	sd_spi->CR1&=0XFFC7;//Fsck=Fcpu/256
	if(SpeedSet==SPI_SPEED_HIGH)//高速
	{
		sd_spi->CR1|=1<<3;//Fsck=Fpclk/4=18Mhz	
	}else//低速
	{
		sd_spi->CR1|=6<<3; //Fsck=Fpclk/256=562.5Khz
	}
	sd_spi->CR1|=1<<6; //SPI设备使能	  
}
	 
/*******************************************************************************
* Function Name  : sd_ReadWriteByte
* Description    : SPI读写一个字节（发送完成后返回本次通讯读取的数据）
* Input          : u8 TxData 待发送的数
* Output         : None
* Return         : u8 RxData 收到的数
*******************************************************************************/
u8 sd_ReadWriteByte(u8 TxData)
{
	while((sd_spi->SR&1<<1)==0);//等待发送区空				  
	sd_spi->DR=TxData;	 	  //发送一个byte   
	while((sd_spi->SR&1<<0)==0);//等待接收完一个byte  
	return sd_spi->DR;          //返回收到的数据				    
}

static
void SD_SPI_Release(void)
{
	SD_CS_DISABLE();
	sd_ReadWriteByte(0xff);;
}

/*******************************************************************************
* Function Name  : SD_WaitReady
* Description    : 等待SD卡Ready
* Input          : None
* Output         : None
* Return         : u8 
*                   0： 成功
*                   other：失败
*******************************************************************************/
u8 SD_WaitReady(void)
{
	u8 r1=MSD_DATA_OTHER_ERROR;
	u32 retry;
#if 0	
	/* retry=0;
	do
	{
		r1=sd_ReadWriteByte(0xFF)&0x1F;//读到回应
		if(retry==0xfffe)return 1;
		retry++;
		switch (r1)
		{
		case MSD_DATA_OK://数据接收正确了
			r1=MSD_DATA_OK;
			break;
		case MSD_DATA_CRC_ERROR: //CRC校验错误
			return MSD_DATA_CRC_ERROR;
		case MSD_DATA_WRITE_ERROR://数据写入错误
			return MSD_DATA_WRITE_ERROR;
		default://未知错误
			r1=MSD_DATA_OTHER_ERROR;
			break;
		}
	}while(r1==MSD_DATA_OTHER_ERROR); //数据错误时一直等待
	*/
	retry=0;
	while(sd_ReadWriteByte(0xFF)==0)//读到数据为0,则数据还未写完成
	{
		retry++;
		//delay_us(10);//SD卡写等待需要较长的时间
		if(retry>=0XFFFFFFFE)return 0XFF;//等待失败了
	};
#else	
	retry = 0;
	do
	{
		r1 = sd_ReadWriteByte(0xFF);
		retry++;
		if(retry>=0xfffffe)return 1; 
	}while(r1!=0xFF); 
#endif	
	return 0;
}	 
/*******************************************************************************
* Function Name  : SD_SendCommand
* Description    : 向SD卡发送一个命令
* Input          : u8 cmd   命令 
*                  u32 arg  命令参数
*                  u8 crc   crc校验值
* Output         : None
* Return         : u8 r1 SD卡返回的响应
*******************************************************************************/
u8 SD_SendCommand(u8 cmd, u32 arg, u8 crc)
{
    unsigned char r1;
    unsigned char Retry = 0;

    //????????
    sd_ReadWriteByte(0xff);
    //片选端置低，选中SD卡
    SD_CS_ENABLE();

    //发送
    sd_ReadWriteByte(cmd | 0x40);                         //分别写入命令
    sd_ReadWriteByte(arg >> 24);
    sd_ReadWriteByte(arg >> 16);
    sd_ReadWriteByte(arg >> 8);
    sd_ReadWriteByte(arg);
    sd_ReadWriteByte(crc);
    
    //等待响应，或超时退出
    while((r1 = sd_ReadWriteByte(0xFF))==0xFF)
    {
        Retry++;
        if(Retry > 200)break; 
    }   
    //关闭片选
    SD_CS_DISABLE();
    //在总线上额外增加8个时钟，让SD卡完成剩下的工作
    sd_ReadWriteByte(0xFF);

    //返回状态值
    return r1;
}


/*******************************************************************************
* Function Name  : SD_SendCommand_NoDeassert
* Description    : 向SD卡发送一个命令(结束是不失能片选，还有后续数据传来）
* Input          : u8 cmd   命令 
*                  u32 arg  命令参数
*                  u8 crc   crc校验值
* Output         : None
* Return         : u8 r1 SD卡返回的响应
*******************************************************************************/
u8 SD_SendCommand_NoDeassert(u8 cmd, u32 arg, u8 crc)
{
    unsigned char r1;
    unsigned char Retry = 0;

    //????????
    sd_ReadWriteByte(0xff);
    //片选端置低，选中SD卡
    SD_CS_ENABLE();

    //发送
    sd_ReadWriteByte(cmd | 0x40);                         //分别写入命令
    sd_ReadWriteByte(arg >> 24);
    sd_ReadWriteByte(arg >> 16);
    sd_ReadWriteByte(arg >> 8);
    sd_ReadWriteByte(arg);
    sd_ReadWriteByte(crc);

    //等待响应，或超时退出
    while((r1 = sd_ReadWriteByte(0xFF))==0xFF)
    {
        Retry++;
        if(Retry > 200)break;   
    }
    //返回响应值
    return r1;
}

/*******************************************************************************
* Function Name  : SD_Init
* Description    : 初始化SD卡
* Input          : None
* Output         : None
* Return         : u8 
*                  0：NO_ERR
*                  1：TIME_OUT
*                  99：NO_CARD
*******************************************************************************/
u8 SD_Init(void)
{
	u16 i;      // 用来循环计数
	u8 r1;      // 存放SD卡的返回值
	u16 retry;  // 用来进行超时计数
	u8 buff[6];
	if(!SD_DETECT) return 99;
	
	sd_spi_SetSpeed(0);
	SD_CS_ENABLE();
					  
	// 纯延时，等待SD卡上电完成
	for(i=0;i<0xf00;i++);

	//先产生>74个脉冲，让SD卡自己初始化完成
	for(i=0;i<10;i++)
	{
		sd_ReadWriteByte(0xFF);
	}

	//-----------------SD卡复位到idle开始-----------------
	//循环连续发送CMD0，直到SD卡返回0x01,进入IDLE状态
	//超时则直接退出
	retry = 0;
	do
	{
		//发送CMD0，让SD卡进入IDLE状态
		r1 = SD_SendCommand(CMD0, 0, 0x95);
		retry++;
	}while((r1 != 0x01) && (retry<200));
	//跳出循环后，检查原因：初始化成功？or 重试超时？
	if(retry==200) return 1;   //超时返回1	  
	//-----------------SD卡复位到idle结束-----------------	 
	//获取卡片的SD版本信息
	r1 = SD_SendCommand_NoDeassert(CMD8, 0x1aa, 0x87);	     
	//如果卡片版本信息是v1.0版本的，即r1=0x05，则进行以下初始化
	if(r1 == 0x05)
	{
		//设置卡类型为SDV1.0，如果后面检测到为MMC卡，再修改为MMC
		SD_Type = SD_TYPE_V1;	   
		//如果是V1.0卡，CMD8指令后没有后续数据
		//片选置高，结束本次命令
		SD_CS_DISABLE();
		//多发8个CLK，让SD结束后续操作
		sd_ReadWriteByte(0xFF);	  
		//-----------------SD卡、MMC卡初始化开始-----------------	 
		//发卡初始化指令CMD55+ACMD41
		// 如果有应答，说明是SD卡，且初始化完成
		// 没有回应，说明是MMC卡，额外进行相应初始化
		retry = 0;
		do
		{
			//先发CMD55，应返回0x01；否则出错
			r1 = SD_SendCommand(CMD55, 0, 0);
			if(r1 != 0x01)return r1;	  
			//得到正确响应后，发ACMD41，应得到返回值0x00，否则重试200次
			r1 = SD_SendCommand(ACMD41, 0, 0);
			retry++;
		}while((r1!=0x00) && (retry<400));
		// 判断是超时还是得到正确回应
		// 若有回应：是SD卡；没有回应：是MMC卡
        
		//----------MMC卡额外初始化操作开始------------
		if(retry==400)
		{
			retry = 0;
			//发送MMC卡初始化命令（没有测试）
			do
			{
				r1 = SD_SendCommand(1, 0, 0);
				retry++;
			}while((r1!=0x00)&& (retry<400));
			if(retry==400)return 1;   //MMC卡初始化超时		    
			//写入卡类型
			SD_Type = SD_TYPE_MMC;
		}
		//----------MMC卡额外初始化操作结束------------	    
		//设置SPI为高速模式
		sd_spi_SetSpeed(1);   
		sd_ReadWriteByte(0xFF);
        
		//禁止CRC校验	   
		r1 = SD_SendCommand(CMD59, 0, 0x95);
		if(r1 != 0x00)return r1;  //命令错误，返回r1   	   
		//设置Sector Size
		r1 = SD_SendCommand(CMD16, 512, 0x95);
		if(r1 != 0x00)return r1;//命令错误，返回r1		 
		//-----------------SD卡、MMC卡初始化结束-----------------

	}//SD卡为V1.0版本的初始化结束	 
	//下面是V2.0卡的初始化
	//其中需要读取OCR数据，判断是SD2.0还是SD2.0HC卡
	else 
		if(r1 == 0x01)
		{
			//V2.0的卡，CMD8命令后会传回4字节的数据，要跳过再结束本命令
			buff[0] = sd_ReadWriteByte(0xFF);  //should be 0x00
			buff[1] = sd_ReadWriteByte(0xFF);  //should be 0x00
			buff[2] = sd_ReadWriteByte(0xFF);  //should be 0x01
			buff[3] = sd_ReadWriteByte(0xFF);  //should be 0xAA	    
			SD_CS_DISABLE();	  
			sd_ReadWriteByte(0xFF);//the next 8 clocks			 
			//判断该卡是否支持2.7V-3.6V的电压范围
			//if(buff[2]==0x01 && buff[3]==0xAA) //不判断，让其支持的卡更多
			{	  
				retry = 0;
				//发卡初始化指令CMD55+ACMD41
				do
				{
					r1 = SD_SendCommand(CMD55, 0, 0);
					if(r1!=0x01)return r1;	   
					r1 = SD_SendCommand(ACMD41, 0x40000000, 0);
					if(retry>200)return r1;  //超时则返回r1状态  
				}while(r1!=0);		  
				//初始化指令发送完成，接下来获取OCR信息		   
				//-----------鉴别SD2.0卡版本开始-----------
				r1 = SD_SendCommand_NoDeassert(CMD58, 0, 0);
				if(r1!=0x00)return r1;  //如果命令没有返回正确应答，直接退出，返回应答		 
				//读OCR指令发出后，紧接着是4字节的OCR信息
				buff[0] = sd_ReadWriteByte(0xFF);
				buff[1] = sd_ReadWriteByte(0xFF); 
				buff[2] = sd_ReadWriteByte(0xFF);
				buff[3] = sd_ReadWriteByte(0xFF);

				//OCR接收完成，片选置高
				SD_CS_DISABLE();
				sd_ReadWriteByte(0xFF);

				//检查接收到的OCR中的bit30位（CCS），确定其为SD2.0还是SDHC
				//如果CCS=1：SDHC   CCS=0：SD2.0
				if(buff[0]&0x40)
					SD_Type = SD_TYPE_V2HC;    //检查CCS	 
				else 
					SD_Type = SD_TYPE_V2;	    
				//-----------鉴别SD2.0卡版本结束----------- 
				//设置SPI为高速模式
				sd_spi_SetSpeed(1);  
			}	    
		}
	return r1;
}



/*******************************************************************************
* Function Name  : SD_ReceiveData
* Description    : 从SD卡中读回指定长度的数据，放置在给定位置
* Input          : u8 *data(存放读回数据的内存>len)
*                  u16 len(数据长度）
*                  u8 release(传输完成后是否释放总线CS置高 0：不释放 1：释放）
* Output         : None
* Return         : u8 
*                  0：NO_ERR
*                  other：错误信息
*******************************************************************************/
u8 SD_ReceiveData(u8 *data, u16 len, u8 release)
{
    u16 retry;
    u8 r1;

    // 启动一次传输
    SD_CS_ENABLE();
    //等待SD卡发回数据起始令牌0xFE
    retry = 0;										   
	do
    {
        r1 = sd_ReadWriteByte(0xFF);
        retry++;
        if(retry>16000)  //2000次等待后没有应答，退出报错
        {
            SD_CS_DISABLE();
            return 1;
        }
    }while(r1 != 0xFE);
		   
    //开始接收数据
    while(len--)
    {
        *data = sd_ReadWriteByte(0xFF);
        data++;
    }
    //下面是2个伪CRC（dummy CRC）
    sd_ReadWriteByte(0xFF);
    sd_ReadWriteByte(0xFF);
    //按需释放总线，将CS置高
    if(release == RELEASE)
    {
        //传输结束
        SD_CS_DISABLE();
        sd_ReadWriteByte(0xFF);
    }											  					    
    return 0;
}


/*******************************************************************************
* Function Name  : SD_GetCID
* Description    : 获取SD卡的CID信息，包括制造商信息
* Input          : u8 *cid_data(存放CID的内存，至少16Byte）
* Output         : None
* Return         : u8 
*                  0：NO_ERR
*                  1：TIME_OUT
*                  other：错误信息
*******************************************************************************/
u8 SD_GetCID(u8 *cid_data)
{
    u8 r1;

    //发CMD10命令，读CID
    r1 = SD_SendCommand(CMD10, 0, 0xFF);
    if(r1 != 0x00)return r1;  //没返回正确应答，则退出，报错    
    //接收16个字节的数据
    SD_ReceiveData(cid_data, 16, RELEASE);	 
    return 0;
}


/*******************************************************************************
* Function Name  : SD_GetCSD
* Description    : 获取SD卡的CSD信息，包括容量和速度信息
* Input          : u8 *cid_data(存放CID的内存，至少16Byte）
* Output         : None
* Return         : u8 
*                  0：NO_ERR
*                  1：TIME_OUT
*                  other：错误信息
*******************************************************************************/
u8 SD_GetCSD(u8 *csd_data)
{
    u8 r1;

    //发CMD9命令，读CSD
    r1 = SD_SendCommand(CMD9, 0, 0xFF);
    if(r1 != 0x00)return r1;  //没返回正确应答，则退出，报错  
    //接收16个字节的数据
    SD_ReceiveData(csd_data, 16, RELEASE);

    return 0;
}


/*******************************************************************************
* Function Name  : SD_GetCapacity
* Description    : 获取SD卡的容量（字节）
* Input          : None
* Output         : None
* Return         : u32 capacity 
*                   0： 取容量出错 
*******************************************************************************/
u32 SD_GetCapacity(void)
{
    u8 csd[16];
    u32 Capacity;
    u8 r1;
    u16 i;
	u16 temp;

    //取CSD信息，如果期间出错，返回0
    if(SD_GetCSD(csd)!=0) return 0;	    
    //如果为SDHC卡，按照下面方式计算
    if((csd[0]&0xC0)==0x40)
    {									  
	    Capacity=((u32)csd[8])<<8;
		Capacity+=(u32)csd[9]+1;	 
        Capacity = (Capacity)*1024;//得到扇区数
		Capacity*=512;//得到字节数			   
    }
    else
    {		    
    	i = csd[6]&0x03;
    	i<<=8;
    	i += csd[7];
    	i<<=2;
    	i += ((csd[8]&0xc0)>>6);
    
        //C_SIZE_MULT
    	r1 = csd[9]&0x03;
    	r1<<=1;
    	r1 += ((csd[10]&0x80)>>7);	 
    	r1+=2;//BLOCKNR
    	temp = 1;
    	while(r1)
    	{
    		temp*=2;
    		r1--;
    	}
    	Capacity = ((u32)(i+1))*((u32)temp);	 
        // READ_BL_LEN
    	i = csd[5]&0x0f;
        //BLOCK_LEN
    	temp = 1;
    	while(i)
    	{
    		temp*=2;
    		i--;
    	}
        //The final result
    	Capacity *= (u32)temp;//字节为单位 	  
    }
    return (u32)Capacity;
}


/*******************************************************************************
* Function Name  : SD_ReadSingleBlock
* Description    : 读SD卡的一个block
* Input          : u32 sector 取地址（sector值，非物理地址） 
*                  u8 *buffer 数据存储地址（大小至少512byte） 
* Output         : None
* Return         : u8 r1 
*                   0： 成功
*                   other：失败
*******************************************************************************/
u8 SD_ReadSingleBlock(u32 sector, u8 *buffer)
{
	u8 r1;

    //设置为高速模式
    sd_spi_SetSpeed(SPI_SPEED_HIGH);
    
    //如果不是SDHC，给定的是sector地址，将其转换成byte地址
    if(SD_Type!=SD_TYPE_V2HC)
    {
        sector = sector<<9;
    }

	r1 = SD_SendCommand(CMD17, sector, 0);//读命令
												    
	if(r1 != 0x00)return r1; 		   							  
	r1 = SD_ReceiveData(buffer, 512, RELEASE);		 
	if(r1 != 0)return r1;   //读数据出错！
    else return 0; 
}

/*******************************************************************************
* Function Name  : SD_WriteSingleBlock
* Description    : 写入SD卡的一个block
* Input          : u32 sector 扇区地址（sector值，非物理地址） 
*                  u8 *buffer 数据存储地址（大小至少512byte） 
* Output         : None
* Return         : u8 r1 
*                   0： 成功
*                   other：失败
*******************************************************************************/
u8 SD_WriteSingleBlock(u32 sector, const u8 *data)
{
    u8 r1;
    u16 i;
    u16 retry;

    //设置为高速模式
    sd_spi_SetSpeed(SPI_SPEED_HIGH);

    //如果不是SDHC，给定的是sector地址，将其转换成byte地址
    if(SD_Type!=SD_TYPE_V2HC)
    {
        sector = sector<<9;
    }

    r1 = SD_SendCommand(CMD24, sector, 0x00);
    if(r1 != 0x00)
    {
        return r1;  //应答不正确，直接返回
    }
    
    //开始准备数据传输
    SD_CS_ENABLE();
    //先放3个空数据，等待SD卡准备好
    sd_ReadWriteByte(0xff);
    sd_ReadWriteByte(0xff);
    sd_ReadWriteByte(0xff);
    //放起始令牌0xFE
    sd_ReadWriteByte(0xFE);

    //放一个sector的数据
    for(i=0;i<512;i++)
    {
        sd_ReadWriteByte(*data++);
    }
    //发2个Byte的dummy CRC
    sd_ReadWriteByte(0xff);
    sd_ReadWriteByte(0xff);
    
    //等待SD卡应答
    r1 = sd_ReadWriteByte(0xff);
    if((r1&0x1F)!=0x05)
    {
        SD_CS_DISABLE();
        return r1;
    }
    
    //等待操作完成
    retry = 0;
    while(!sd_ReadWriteByte(0xff))
    {
        retry++;
        if(retry>0xfffe)        //如果长时间写入没有完成，报错退出
        {
            SD_CS_DISABLE();
            return 1;           //写入超时返回1
        }
    }

    //写入完成，片选置1
    SD_CS_DISABLE();
    sd_ReadWriteByte(0xff);

    return 0;
}


/*******************************************************************************
* Function Name  : SD_ReadMultiBlock
* Description    : 读SD卡的多个block
* Input          : u32 sector 取地址（sector值，非物理地址） 
*                  u8 *buffer 数据存储地址（大小至少512byte）
*                  u8 count 连续读count个block
* Output         : None
* Return         : u8 r1 
*                   0： 成功
*                   other：失败
*******************************************************************************/
u8 SD_ReadMultiBlock(u32 sector, u8 *buffer, u8 count)
{
    u8 r1;	 			 
    sd_spi_SetSpeed(SPI_SPEED_HIGH);//设置为高速模式  
    if(SD_Type != SD_TYPE_V2HC)
		sector = sector<<9;//如果不是SDHC，将sector地址转成byte地址
    // SD_WaitReady();
    //发读多块命令
	r1 = SD_SendCommand(CMD18, sector, 0);//读命令
	if(r1 != 0x00)return r1;	 
    do//开始接收数据
    {
        if(SD_ReceiveData(buffer, 512, NO_RELEASE) != 0x00)
        {
            break;
        }
        buffer += 512;
    } while(--count);		 
    //全部传输完毕，发送停止命令
    SD_SendCommand(CMD12, 0, 0);
    //释放总线
    SD_CS_DISABLE();
    sd_ReadWriteByte(0xFF);    
    if(count != 0)return count;   //如果没有传完，返回剩余个数	 
    else return 0;	 
}


/*******************************************************************************
* Function Name  : SD_WriteMultiBlock
* Description    : 写入SD卡的N个block
* Input          : u32 sector 扇区地址（sector值，非物理地址） 
*                  u8 *buffer 数据存储地址（大小至少512byte）
*                  u8 count 写入的block数目
* Output         : None
* Return         : u8 r1 
*                   0： 成功
*                   other：失败
*******************************************************************************/
u8 SD_WriteMultiBlock(u32 sector, const u8 *data, u8 count)
{
    u8 r1;
    u16 i;	 		 
    sd_spi_SetSpeed(SPI_SPEED_HIGH);//设置为高速模式	 
    if(SD_Type != SD_TYPE_V2HC)sector = sector<<9;//如果不是SDHC，给定的是sector地址，将其转换成byte地址  
    if(SD_Type != SD_TYPE_MMC) r1 = SD_SendCommand(ACMD23, count, 0x00);//如果目标卡不是MMC卡，启用ACMD23指令使能预擦除   
    r1 = SD_SendCommand(CMD25, sector, 0x00);//发多块写入指令
    if(r1 != 0x00)return r1;  //应答不正确，直接返回	 
    SD_CS_ENABLE();//开始准备数据传输   
    sd_ReadWriteByte(0xff);//先放3个空数据，等待SD卡准备好
    sd_ReadWriteByte(0xff);   
    sd_ReadWriteByte(0xff);   
    //--------下面是N个sector写入的循环部分
    do
    {
        //放起始令牌0xFC 表明是多块写入
        sd_ReadWriteByte(0xFC);	  
        //放一个sector的数据
        for(i=0;i<512;i++)
        {
            sd_ReadWriteByte(*data++);
        }
        //发2个Byte的dummy CRC
        sd_ReadWriteByte(0xff);
        sd_ReadWriteByte(0xff);
        
        //等待SD卡应答
        r1 = sd_ReadWriteByte(0xff);
        if((r1&0x1F)!=0x05)
        {
            SD_CS_DISABLE();    //如果应答为报错，则带错误代码直接退出
            return r1;
        }

        //等待SD卡写入完成
        if(SD_WaitReady()==1)
        {
            SD_CS_DISABLE();    //等待SD卡写入完成超时，直接退出报错
            return 1;
        }	   
    }while(--count);//本sector数据传输完成
    
    //发结束传输令牌0xFD
    r1 = sd_ReadWriteByte(0xFD);
    if(r1==0x00)
    {
        count =  0xfe;
    }		   
    if(SD_WaitReady()) //等待准备好
	{
		SD_CS_DISABLE();
		return 1;  
	}
    //写入完成，片选置1
    SD_CS_DISABLE();
    sd_ReadWriteByte(0xff);  
    return count;   //返回count值，如果写完则count=0，否则count=1
}
											 
/*******************************************************************************
* Function Name  : SD_Read_Bytes
* Description    : 在指定扇区,从offset开始读出bytes个字节
* Input          : u32 address 扇区地址（sector值，非物理地址） 
*                  u8 *buf     数据存储地址（大小<=512byte）
*                  u16 offset  在扇区里面的偏移量
                   u16 bytes   要读出的字节数
* Output         : None
* Return         : u8 r1 
*                   0： 成功
*                   other：失败
*******************************************************************************/
u8 SD_Read_Bytes(unsigned long address,unsigned char *buf,unsigned int offset,unsigned int bytes)
{
    u8 r1;u16 i=0;  
    r1=SD_SendCommand(CMD17,address<<9,0);//发送读扇区命令      
    if(r1!=0x00)return r1;  //应答不正确，直接返回
	SD_CS_ENABLE();//选中SD卡
	while (sd_ReadWriteByte(0xff)!= 0xFE)//直到读取到了数据的开始头0XFE，才继续
	{
		i++;
		if(i>2000)
		{
			SD_CS_DISABLE();//关闭SD卡
			return 1;//读取失败
		}
	}; 		 
	for(i=0;i<offset;i++)sd_ReadWriteByte(0xff);//跳过offset位 
    for(;i<offset+bytes;i++)*buf++=sd_ReadWriteByte(0xff);//读取有用数据	
    for(;i<512;i++) sd_ReadWriteByte(0xff); 	 //读出剩余字节
    sd_ReadWriteByte(0xff);//发送伪CRC码
    sd_ReadWriteByte(0xff);  
    SD_CS_DISABLE();//关闭SD卡
	return 0;
}

/*--------------------------------------------------------------------------

  Public Functions

  ---------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------*/
/* Initialize Disk Drive                                                 */
/*-----------------------------------------------------------------------*/
//在auto_mount()内调用
DSTATUS msd_disk_initialize ()
{
	BYTE ty;//, ocr[16], cmd;
	//int n;
#if 1
	ty= SD_Init();
#else	
	SD_SPI_Config(); //初始化IO

	for (Timer1=50; Timer1; );              

	sd_spi_SetSpeed(SPI_SPEED_LOW);
	SD_CS_DISABLE();							//不选SD

	/* Wait for enter Idle state in timeout of 5000 msec */
	Timer1 = 500;
	do
	{
		for (n = 10; n; n--) sd_ReadWriteByte(0xff);		/* 80 dummy clocks */
	}
	while ((SD_Send_Command(CMD0,0) != 1) && Timer1);

	ty = 0;
	Timer1 = 200;					/* Initialization timeout of 2000 msec */
	if (Send_Command(CMD8, 0x1AA) == 1)		  /* 检查是否支持SDC Ver2 */
	{
		for (n = 0; n < 4; n++)
			ocr[n] = SPI_ReadWrite_Byte(0xff);	/* Get trailing return value of R7 resp */
		if (ocr[2] == 0x01 && ocr[3] == 0xAA)
		{
			/* The card can work at vdd range of 2.7-3.6V */
			/* Wait for leaving idle state (ACMD41 with HCS bit) */
			while (Timer1 && Send_Command(ACMD41, 1UL << 30));                  
			if (Timer1 && Send_Command(CMD58, 0) == 0)
			{
				/* Check CCS bit in the OCR */
				for (n = 0; n < 4; n++)
					ocr[n] = SPI_ReadWrite_Byte(0xff);
				/* When CCS bit is set  R/W in block address insted of byte address */
				ty = (ocr[0] & 0x40) ? 12 : 4;
			}
		}
	}
	else
	{
		/* SDSC or MMC */
		if (Send_Command(ACMD41, 0) <= 1)			/* initialize successful will response 0x00 */
		{
			ty = 2; cmd = ACMD41;	/* SDv1 */
		}
		else
		{
			ty = 1; cmd = CMD1;		/* MMC */
		}
		while (Timer1 && Send_Command(cmd, 0));			/* Wait for leaving idle state */
		if (!Timer1 || Send_Command(CMD16, 512) != 0)	/* Set R/W block length to 512 */
			ty = 0;
	}

	CardType = ty;  
	SPI_HighSpeed();
	SD_SPI_Release();
#endif
	if (ty==0)
	{
		/* Initialization succeded */
		msd_Stat &= ~STA_NOINIT;    
		//    USART1_Puts("Initialization succeded.\n");
	}
	else
	{
		/* Initialization failed */
		//    USART1_Puts("Initialization failed.\n");
	}

	return msd_Stat;
}


/*-----------------------------------------------------------------------*/
/* Get Disk Status                                                       */
/*-----------------------------------------------------------------------*/
DSTATUS msd_disk_status ()
{
	return msd_Stat;
}

/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
/*-----------------------------------------------------------------------*/
DRESULT msd_disk_read (
				  BYTE *buff,		  /* Pointer to the data buffer to store read data */
				  DWORD sector,				  /* Start sector number (LBA) */
				  BYTE count		  /* Sector count (1..255) */
				  )
{
	if (!count) return RES_PARERR;
	if (msd_Stat & STA_NOINIT) return RES_NOTRDY;

	return SD_ReadMultiBlock(sector, (u8 *)buff, count) ? RES_ERROR : RES_OK;
}



/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
/*-----------------------------------------------------------------------*/
#if _READONLY == 0
DRESULT msd_disk_write (
				   const BYTE *buff,   /* Pointer to the data to be written */
				   DWORD sector,	   /* Start sector number (LBA) */
				   BYTE count		   /* Sector count (1..255) */
				   )
{
	if (!count) return RES_PARERR;
	if (msd_Stat & STA_NOINIT) return RES_NOTRDY;
	if (msd_Stat & STA_PROTECT)	return RES_WRPRT;
#if 0
	while(count--)
	{
		if( SD_WriteSingleBlock(sector++, buff))
			break;
		buff+= 512;
	}
	return count?RES_ERROR:RES_OK;
#else
	return SD_WriteMultiBlock(sector, (u8 *)buff, count)? RES_ERROR : RES_OK;
#endif
}
#endif /* _READONLY == 0 */



/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

#if _USE_IOCTL != 0
DRESULT msd_disk_ioctl (
				   BYTE ctrl,	   /* Control code */
				   void *buff	   /* Buffer to send/receive control data */
				   )
{
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	//WORD csize;

	res = RES_ERROR;

	if (ctrl == CTRL_POWER)
	{
		switch (*ptr)
		{
		case 0:		/* Sub control code == 0 (POWER_OFF) */
			res = RES_OK;
			break;
		case 1:		/* Sub control code == 1 (POWER_ON) */
			res = RES_OK;
			break;
		case 2:		/* Sub control code == 2 (POWER_GET) */
			*(ptr+1) = (BYTE)1;//chk_power();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
		}
	}
	else
	{
		if (msd_Stat & STA_NOINIT) return RES_NOTRDY;

		switch (ctrl)
		{
		case CTRL_SYNC :		/* Make sure that no pending write process */
			SD_CS_ENABLE();
			if (SD_WaitReady()== 0)
				res = RES_OK;
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((*(DWORD*)buff = SD_GetCapacity())>0)
				res = RES_OK;
			break;

		case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
			*(WORD*)buff = 512;
			res = RES_OK;
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			if(SD_GetCSD(csd)==0)
			{
				if (SD_Type>=SD_TYPE_V2)		  /* SDC ver 2.00 */
				{
					for (n = 64 - 16; n; n--) sd_ReadWriteByte(0xff);	/* Purge trailing data */
					*(DWORD*)buff = 16UL << (csd[10] >> 4);
				}else
				{
					if (SD_Type == SD_TYPE_V1)		  /* SDC ver 1.XX */
					{
						*(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
					}
					else					/* MMC */
					{
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
					}
				}
				res = RES_OK;
			}
			break;

		case MMC_GET_TYPE :		/* Get card type flags (1 byte) */
			*ptr = SD_Type;
			res = RES_OK;
			break;

		case MMC_GET_CSD :		/* Receive CSD as a data block (16 bytes) */
			if(SD_GetCSD((u8 *)buff)==0)
				res = RES_OK;
			break;

		case MMC_GET_CID :		/* Receive CID as a data block (16 bytes) */
			if (SD_GetCID((u8 *)buff)==0)
				res = RES_OK;
			break;
#if 0
		case MMC_GET_OCR :		/* Receive OCR as an R3 resp (4 bytes) */
			if (SD_SendCommand(CMD58, 0, 0xFF) == 0)  /* READ_OCR */
			{
				for (n = 4; n; n--)	*ptr++ = SPI_ReadWrite_Byte(0xff);
				res = RES_OK;
			}
			break;

		case MMC_GET_SDSTAT :	/* Receive SD statsu as a data block (64 bytes) */
			if (Send_Command(ACMD13, 0) == 0) /* SD_STATUS */
			{
				SPI_ReadWrite_Byte(0xff);
				if (Receive_DataBlock(ptr, 64))
					res = RES_OK;
			}
			break;
#endif
		default:
			res = RES_PARERR;
		}

	}

	SD_SPI_Release();
	return res;
}
#endif /* _USE_IOCTL != 0 */

DWORD get_fattime (void)
{
	return 0;  
}

